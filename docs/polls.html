<!--
Polls feature for Watchlist Voting
Includes: HTML, CSS, JavaScript, and Supabase SQL (at the end inside this file as a comment)
Copy this file as polls.html next to your existing pages. Update any nav links as needed.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Polls</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body { margin:0; background:#121212; color:#fff; font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    header { display:flex; align-items:center; justify-content:space-between; padding:12px 16px; position:sticky; top:0; background:rgba(18,18,18,.9); border-bottom:1px solid #222; z-index:20; }
    h1 { font-size:1.05rem; margin:0; }
    main { padding:16px; max-width:1040px; margin:0 auto; }
    .card { background:#1e1e1e; border:1px solid #2a2a2a; border-radius:12px; padding:14px; box-shadow:0 2px 12px rgba(0,0,0,.25); }
    .row { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
    .row input, .row textarea { background:#0f0f0f; color:#fff; border:1px solid #333; border-radius:10px; padding:.6rem .7rem; }
    .row textarea { width:100%; min-height:96px; }
    .btn { padding:.6rem .9rem; border-radius:10px; border:1px solid #333; background:#1f2937; color:#fff; cursor:pointer; transition:opacity .15s ease; }
    .btn:hover { background:#273244; }
    .btn[disabled] { opacity:.6; cursor:not-allowed; }
    .btn-cta { background:#2563eb; border-color:#2563eb; }
    .btn-cta:hover { background:#1d4ed8; }
    .btn-ghost { background:#111; }
    .grid { display:grid; grid-template-columns: 1fr; gap:.75rem; margin-top:1rem; }
    @media (min-width: 980px) { .grid { grid-template-columns: 1fr 1fr; } }

    .poll { display:flex; flex-direction:column; gap:.6rem; background:#171717; border:1px solid #262626; border-radius:12px; padding:12px; }
    .poll-head { display:flex; gap:.75rem; align-items:center; justify-content:space-between; }
    .muted { color:#9aa0a6; font-size:.9rem; }
    .title { font-weight:700; font-size:1rem; }
    .sep { height:1px; background:#262626; margin:.25rem 0; }
    .option { display:flex; align-items:center; justify-content:space-between; gap:.75rem; padding:.45rem .55rem; border:1px solid #2a2a2a; border-radius:10px; background:#141414; }
    .option .left { display:flex; flex-direction:column; gap:.2rem; }
    .chips { display:flex; flex-wrap:wrap; gap:.3rem; }
    .chip { display:inline-flex; align-items:center; gap:.3rem; padding:.1rem .45rem; border:1px solid #333; border-radius:999px; font-size:.78rem; background:#0f0f0f; }
    .me { border-color:#60a5fa; }
    .ended { color:#fca5a5; }
    .success { color:#86efac; }

    .loading-veil { position: fixed; inset: 0; background: rgba(0,0,0,.45); display: none; align-items: center; justify-content: center; z-index: 50; backdrop-filter: blur(2px); }
    .loading-box { background:#1d1d1d; border:1px solid #2a2a2a; border-radius:12px; padding:14px 16px; display:flex; align-items:center; gap:.75rem; box-shadow:0 6px 24px rgba(0,0,0,.35); }
    .spinner { width:18px; height:18px; border:3px solid #2f2f2f; border-top-color:#60a5fa; border-radius:50%; animation: spin 0.8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .section-title { margin:.25rem 0 .5rem 0; font-size:1rem; }
  </style>
</head>
<body>
  <header>
    <h1>Polls</h1>
    <div>
      <button class="btn" onclick="location.href='members.html'">Back to dashboard</button>
      <button class="btn" onclick="location.href='watchlist.html'">Watchlist</button>
      <button class="btn danger" id="btnSignOut">Sign out</button>
    </div>
  </header>

  <div id="loading" class="loading-veil" aria-hidden="true">
    <div class="loading-box">
      <div class="spinner" aria-label="Loading"></div>
      <div id="loadingText">Loading, please wait</div>
    </div>
  </div>

  <main>
    <section class="card" style="margin-bottom:1rem;">
      <h2 class="section-title">Create a poll</h2>
      <div class="row">
        <input id="title" placeholder="Poll title" style="flex:1; min-width:220px;" />
        <input id="duration" type="number" min="1" max="72" value="72" style="width:120px;" />
        <label class="muted">hours, limit 72</label>
      </div>
      <div class="row" style="margin-top:.5rem;">
        <textarea id="options" placeholder="Options, one per line"></textarea>
      </div>
      <div class="row" style="justify-content:flex-end;">
        <button id="btnCreate" class="btn btn-cta">Create poll</button>
      </div>
      <div id="createMsg" class="muted" style="margin-top:.5rem;"></div>
    </section>

    <section class="card" style="margin-bottom:1rem;">
      <div class="row" style="justify-content:space-between; margin-bottom:.5rem;">
        <h2 class="section-title" style="margin:0;">Active polls</h2>
        <div class="row">
          <label class="muted">Filter</label>
          <input id="search" placeholder="Type to filter" />
        </div>
      </div>
      <div id="activeList" class="grid"></div>
    </section>

    <section class="card">
      <div class="row" style="justify-content:space-between; margin-bottom:.5rem;">
        <h2 class="section-title" style="margin:0;">Completed</h2>
        <div class="row">
          <label class="muted">Filter</label>
          <input id="archSearch" placeholder="Filter completed" />
        </div>
      </div>
      <div id="archList" class="grid"></div>
    </section>
  </main>

  <script>
    const SUPABASE_URL = "https://acdlgvcxzxjvcwiqlydj.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFjZGxndmN4enhqdmN3aXFseWRqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY2Mjc5NzksImV4cCI6MjA3MjIwMzk3OX0.9ZUURjJT73Igd2tAOv8aSZUmlkEf7DIzmOAGBSjWqCI";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    let currentUser = null;
    let polls = [];
    let options = [];
    let votes = [];

    const loadingEl = document.getElementById("loading");
    const loadingTextEl = document.getElementById("loadingText");
    let loadingDepth = 0;
    function setLoading(on, text) { if (on) { loadingDepth += 1; if (text) loadingTextEl.textContent = text; loadingEl.style.display = "flex"; } else { loadingDepth = Math.max(0, loadingDepth - 1); if (loadingDepth === 0) loadingEl.style.display = "none"; } }
    async function withLoading(label, fn) { try { setLoading(true, label); return await fn(); } finally { setLoading(false); } }

    function showMsg(el, text, ok=true) { el.textContent = text; el.className = ok ? "success" : "ended"; setTimeout(()=>{ el.textContent = ""; el.className = "muted"; }, 2000); }

    function escapeHtml(s) { return String(s).replace(/[&<>"']/g, c => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c] || c)); }

    async function guard() {
      const sess = await supabase.auth.getSession();
      const session = sess?.data?.session;
      if (!session) { location.href = "login.html"; return; }
      const usr = await supabase.auth.getUser();
      currentUser = usr?.data?.user;
      if (!currentUser) { location.href = "login.html"; return; }
    }

    function nowUtcIso() { return new Date().toISOString(); }

    function formatCountdown(endIso) {
      const end = new Date(endIso).getTime();
      const diff = end - Date.now();
      if (diff <= 0) return "Ended";
      const h = Math.floor(diff / 3600000);
      const m = Math.floor((diff % 3600000) / 60000);
      const s = Math.floor((diff % 60000) / 1000);
      return `${h}h ${m}m ${s}s left`;
    }

    async function fetchAll() {
      const p = await supabase.from("polls").select("*").order("created_at", { ascending:false });
      if (p.error) throw p.error;
      polls = p.data || [];
      const o = await supabase.from("poll_options").select("*");
      if (o.error) throw o.error;
      options = o.data || [];
      const v = await supabase.from("poll_votes").select("*");
      if (v.error) throw v.error;
      votes = v.data || [];
    }

    function isEnded(poll) { return new Date(poll.end_at).getTime() <= Date.now(); }

    function myDisplayName() {
      const firstName = currentUser?.user_metadata?.first_name || "";
      const fallback = (currentUser?.email || "").split("@")[0] || "Member";
      return firstName || fallback;
    }

    async function createPoll() {
      const title = document.getElementById("title").value.trim();
      const duration = Math.min(72, Math.max(1, Number(document.getElementById("duration").value || 72)));
      const optsText = document.getElementById("options").value.trim();
      const msg = document.getElementById("createMsg");
      if (!title) { showMsg(msg, "Please enter a title", false); return; }
      const opts = optsText.split(/\n/).map(s => s.trim()).filter(Boolean).slice(0, 20);
      if (opts.length < 2) { showMsg(msg, "Add at least two options", false); return; }

      await withLoading("Creating poll", async () => {
        const endAt = new Date(Date.now() + duration * 3600000).toISOString();
        const ins = await supabase.from("polls").insert({ title, created_by: currentUser.id, end_at: endAt });
        if (ins.error) throw ins.error;
        const poll = (ins.data && ins.data[0]) ? ins.data[0] : null;
        if (!poll) throw new Error("Could not create poll");
        const rows = opts.map(label => ({ poll_id: poll.id, label }));
        const insOpt = await supabase.from("poll_options").insert(rows).select("*");
        if (insOpt.error) throw insOpt.error;
        document.getElementById("title").value = "";
        document.getElementById("options").value = "";
        document.getElementById("duration").value = 72;
        showMsg(msg, "Poll created");
      });
    }

    async function vote(pollId, optionId) {
      const displayName = myDisplayName();
      await withLoading("Submitting vote", async () => {
        const up = await supabase.from("poll_votes").upsert({ poll_id: pollId, option_id: optionId, user_id: currentUser.id, voter_name: displayName }, { onConflict: "poll_id,user_id" });
        if (up.error) throw up.error;
      });
    }

    function buildIndex() {
      const optByPoll = new Map();
      for (const o of options) {
        if (!optByPoll.has(o.poll_id)) optByPoll.set(o.poll_id, []);
        optByPoll.get(o.poll_id).push(o);
      }
      const votesByPoll = new Map();
      for (const v of votes) {
        if (!votesByPoll.has(v.poll_id)) votesByPoll.set(v.poll_id, []);
        votesByPoll.get(v.poll_id).push(v);
      }
      const votesByOption = new Map();
      for (const v of votes) {
        if (!votesByOption.has(v.option_id)) votesByOption.set(v.option_id, []);
        votesByOption.get(v.option_id).push(v);
      }
      return { optByPoll, votesByPoll, votesByOption };
    }

    function renderLists() {
      const q = (document.getElementById("search").value || "").trim().toLowerCase();
      const aq = (document.getElementById("archSearch").value || "").trim().toLowerCase();
      const activeWrap = document.getElementById("activeList");
      const archWrap = document.getElementById("archList");
      activeWrap.innerHTML = ""; archWrap.innerHTML = "";
      const { optByPoll, votesByPoll, votesByOption } = buildIndex();

      const active = polls.filter(p => !isEnded(p) && (!q || p.title.toLowerCase().includes(q)));
      const ended = polls.filter(p => isEnded(p) && (!aq || p.title.toLowerCase().includes(aq)));

      function renderPoll(p, parent) {
        const opts = (optByPoll.get(p.id) || []).slice();
        const pVotes = votesByPoll.get(p.id) || [];
        const myVote = pVotes.find(v => v.user_id === currentUser.id);
        const endedState = isEnded(p);
        const total = pVotes.length;
        opts.sort((a,b) => a.label.localeCompare(b.label));
        const box = document.createElement("div");
        box.className = "poll";
        const cd = endedState ? "Ended" : formatCountdown(p.end_at);
        box.innerHTML = `
          <div class="poll-head">
            <div>
              <div class="title">${escapeHtml(p.title)}</div>
              <div class="muted">Ends at ${new Date(p.end_at).toLocaleString()} (${escapeHtml(cd)})</div>
            </div>
            ${endedState ? '<div class="ended">Voting closed</div>' : ''}
          </div>
          <div class="sep"></div>
        `;
        opts.forEach(o => {
          const arr = votesByOption.get(o.id) || [];
          const count = arr.length;
          const you = myVote && myVote.option_id === o.id;
          const chipHtml = arr.map(v => `<span class="chip ${v.user_id===currentUser.id?'me':''}">${escapeHtml(v.voter_name || 'Member')}</span>`).join(' ');
          const row = document.createElement('div');
          row.className = 'option';
          row.innerHTML = `
            <div class="left">
              <div><strong>${escapeHtml(o.label)}</strong> <span class="muted">(${count} vote${count===1?'':'s'})</span></n></div>
              <div class="chips">${chipHtml || '<span class="muted">No votes yet</span>'}</div>
            </div>
            <div>
              <button class="btn ${you?'btn-cta':''}" ${endedState?'disabled':''} data-poll="${p.id}" data-opt="${o.id}">${you?'Your vote':'Vote'}</button>
            </div>
          `;
          box.appendChild(row);
        });
        parent.appendChild(box);
      }

      if (!active.length) activeWrap.innerHTML = '<div class="muted">No active polls</div>';
      if (!ended.length) archWrap.innerHTML = '<div class="muted">No completed polls</div>';

      active.forEach(p => renderPoll(p, activeWrap));
      ended.forEach(p => renderPoll(p, archWrap));

      document.querySelectorAll('.option .btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          const pollId = btn.getAttribute('data-poll');
          const optId = btn.getAttribute('data-opt');
          try { await vote(pollId, optId); await fetchAll(); renderLists(); } catch(e) { alert(e.message || e); }
        });
      });
    }

    function setupRealtime() {
      const channel = supabase.channel('polls_rt');
      channel.on('postgres_changes', { event:'*', schema:'public', table:'polls' }, async () => { await fetchAll(); renderLists(); });
      channel.on('postgres_changes', { event:'*', schema:'public', table:'poll_options' }, async () => { await fetchAll(); renderLists(); });
      channel.on('postgres_changes', { event:'*', schema:'public', table:'poll_votes' }, async () => { await fetchAll(); renderLists(); });
      channel.subscribe();
    }

    document.getElementById('btnCreate').addEventListener('click', createPoll);
    document.getElementById('search').addEventListener('input', ()=> renderLists());
    document.getElementById('archSearch').addEventListener('input', ()=> renderLists());
    document.getElementById('btnSignOut').addEventListener('click', async () => { await supabase.auth.signOut(); location.href = 'login.html'; });

    async function init() {
      await withLoading('Loading polls', async () => { await guard(); await fetchAll(); renderLists(); setupRealtime(); });
      setInterval(()=> { renderLists(); }, 1000);
    }
    init();
  </script>
</body>
</html>

<!--
====================================
Supabase SQL, run in the SQL editor
====================================
This creates tables, constraints, indexes, and policies that enforce a 72 hour time limit, and allow one vote per user per poll. It also stores a snapshot of voter_name to display who voted where.

Note, adjust schema names if you use a different schema. Public is assumed.
-->

<!--
-- 1. Tables
-->

/* Polls table */
create table if not exists public.polls (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  created_by uuid not null references auth.users(id) on delete cascade,
  created_at timestamptz not null default now(),
  end_at timestamptz not null,
  constraint polls_duration_max check ( end_at <= created_at + interval '72 hours' )
);

/* Options for each poll */
create table if not exists public.poll_options (
  id uuid primary key default gen_random_uuid(),
  poll_id uuid not null references public.polls(id) on delete cascade,
  label text not null,
  created_at timestamptz not null default now()
);

/* Votes, one per user per poll, user can change vote until poll ends */
create table if not exists public.poll_votes (
  poll_id uuid not null references public.polls(id) on delete cascade,
  option_id uuid not null references public.poll_options(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  voter_name text not null default '',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  primary key (poll_id, user_id)
);

/* keep updated_at fresh */
create or replace function public.touch_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end;$$;

drop trigger if exists trg_poll_votes_touch on public.poll_votes;
create trigger trg_poll_votes_touch
before update on public.poll_votes
for each row execute procedure public.touch_updated_at();

/* helpful indexes */
create index if not exists idx_poll_options_poll on public.poll_options(poll_id);
create index if not exists idx_poll_votes_poll on public.poll_votes(poll_id);
create index if not exists idx_poll_votes_option on public.poll_votes(option_id);

-- 2. Row level security
alter table public.polls enable row level security;
alter table public.poll_options enable row level security;
alter table public.poll_votes enable row level security;

/* Polls policies */
create policy if not exists polls_select_all on public.polls
for select using ( auth.role() = 'anon' or auth.role() = 'authenticated' );

create policy if not exists polls_insert_own on public.polls
for insert with check ( auth.uid() = created_by );

create policy if not exists polls_update_own on public.polls
for update using ( auth.uid() = created_by ) with check ( auth.uid() = created_by );

create policy if not exists polls_delete_own on public.polls
for delete using ( auth.uid() = created_by );

/* Poll options policies */
create policy if not exists options_select_all on public.poll_options
for select using ( true );

create policy if not exists options_insert_if_owner on public.poll_options
for insert with check (
  exists (
    select 1 from public.polls p
    where p.id = poll_id and p.created_by = auth.uid()
  )
);

create policy if not exists options_update_if_owner on public.poll_options
for update using (
  exists (
    select 1 from public.polls p
    where p.id = poll_id and p.created_by = auth.uid()
  )
) with check (
  exists (
    select 1 from public.polls p
    where p.id = poll_id and p.created_by = auth.uid()
  )
);

create policy if not exists options_delete_if_owner on public.poll_options
for delete using (
  exists (
    select 1 from public.polls p
    where p.id = poll_id and p.created_by = auth.uid()
  )
);

/* Votes policies, select by all, insert or update by the voter while poll is active */
create policy if not exists votes_select_all on public.poll_votes
for select using ( true );

create policy if not exists votes_insert_if_active on public.poll_votes
for insert with check (
  user_id = auth.uid()
  and exists (
    select 1 from public.polls p
    where p.id = poll_id and p.end_at > now()
  )
  and exists (
    select 1 from public.poll_options o
    where o.id = option_id and o.poll_id = poll_id
  )
);

create policy if not exists votes_update_if_active on public.poll_votes
for update using (
  user_id = auth.uid()
  and exists (
    select 1 from public.polls p
    where p.id = poll_id and p.end_at > now()
  )
) with check (
  user_id = auth.uid()
  and exists (
    select 1 from public.polls p
    where p.id = poll_id and p.end_at > now()
  )
  and exists (
    select 1 from public.poll_options o
    where o.id = option_id and o.poll_id = poll_id
  )
);

create policy if not exists votes_delete_own on public.poll_votes
for delete using ( user_id = auth.uid() );

-- 3. Optional, prevent creating polls with end_at older than now, server side
create or replace function public.polls_end_not_past()
returns trigger language plpgsql as $$
begin
  if new.end_at <= now() then
    raise exception 'end_at must be in the future';
  end if;
  return new;
end;$$;

drop trigger if exists trg_polls_future on public.polls;
create trigger trg_polls_future
before insert on public.polls
for each row execute procedure public.polls_end_not_past();

-- 4. Realtime, remember to add these tables in Supabase Realtime settings if needed
--    public.polls, public.poll_options, public.poll_votes


/*
Notes
- Client shows voter names from voter_name snapshot, change later by editing your profile logic if you want.
- Duration constraint enforces at most 72 hours. UI defaults to 72. Users can choose less.
- One vote per user per poll, upsert lets a voter change to another option before the poll ends.
- Selector queries are wide open for authenticated users, adjust if you need stricter visibility.
*/
-->


